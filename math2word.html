<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Chuy·ªÉn To√°n h·ªçc sang DOCX (B·∫£n 00000 cu·ªëi)</title>
  <style>
    body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; display: flex; justify-content: center; align-items: center; flex-direction: column; padding: 20px; background-color: #f4f4f9; margin: 0; }
    .container { width: 100%; max-width: 800px; background: white; padding: 25px; border-radius: 8px; box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
    h2 { text-align: center; color: #333; margin-top: 0; margin-bottom: 20px; }
    textarea { width: 100%; height: 250px; padding: 12px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; margin-bottom: 15px; box-sizing: border-box; line-height: 1.6; }
    input[type="text"] { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; margin-bottom: 20px; box-sizing: border-box; }
    button { width: 100%; padding: 12px; background-color: #28a745; color: white; border: none; border-radius: 4px; font-size: 18px; cursor: pointer; transition: background-color 0.2s; }
    button:hover { background-color: #218838; }
    button:disabled { background-color: #ccc; cursor: not-allowed; }
  </style>

  <!-- docx & FileSaver -->
  <script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.min.js" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js" crossorigin="anonymous"></script>

  <script>
    // C·∫•u h√¨nh MathJax tr∆∞·ªõc khi t·∫£i script ch√≠nh
    MathJax = {
      loader: { load: ["input/tex", "output/svg"] },
      svg: { fontCache: "global" },
      startup: {
        ready: () => {
          console.log("MathJax ready");
          MathJax.startup.defaultReady();
          main();
        }
      }
    };

    function main() {
      const { Document, Packer, Paragraph, TextRun, ImageRun, AlignmentType } = docx;

      const downloadBtn = document.getElementById("downloadBtn");
      const mathInput = document.getElementById("mathInput");
      const fileNameInput = document.getElementById("fileName");
      const renderDiv = document.getElementById("render-hidden");

      function svgStringToBase64(svgString) {
        return new Promise((resolve) => {
          const blob = new Blob([svgString], { type: "image/svg+xml" });
          const reader = new FileReader();
          reader.onloadend = () => {
            const base64data = reader.result.split(",")[1];
            resolve(base64data);
          };
          reader.readAsDataURL(blob);
        });
      }

      // FIX QUAN TR·ªåNG: docx.ImageRun c·∫ßn Uint8Array, kh√¥ng ph·∫£i chu·ªói base64
      function base64ToUint8Array(base64) {
        const binary = atob(base64);
        const len = binary.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) bytes[i] = binary.charCodeAt(i);
        return bytes;
      }

      async function renderMathToImage(latex) {
        // ƒê·∫∑t LaTeX v√†o v√πng ·∫©n ƒë·ªÉ MathJax render
        renderDiv.innerHTML = latex;
        await MathJax.typesetPromise([renderDiv]);
        const svgElement = renderDiv.querySelector("svg");
        if (!svgElement) return null;

        // ƒê·∫£m b·∫£o namespace
        svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");

        // L·∫•y k√≠ch th∆∞·ªõc t·ª´ thu·ªôc t√≠nh SVG (th∆∞·ªùng ·ªü ƒë∆°n v·ªã ex)
        const wAttr = svgElement.getAttribute("width") || "0";
        const hAttr = svgElement.getAttribute("height") || "0";
        const wNum = parseFloat(wAttr.replace("ex", ""));
        const hNum = parseFloat(hAttr.replace("ex", ""));
        // Quy ƒë·ªïi th√¥: 1ex ~ 8.5px (theo b·∫£n g·ªëc), c√≥ th·ªÉ tinh ch·ªânh n·∫øu c·∫ßn
        const width = (isNaN(wNum) ? 0 : wNum) * 8.5;
        const height = (isNaN(hNum) ? 0 : hNum) * 8.5;

        // Serialize SVG ‚Üí base64 ‚Üí Uint8Array
        const serializer = new XMLSerializer();
        const svgString = serializer.serializeToString(svgElement);
        const base64Image = await svgStringToBase64(svgString);
        const bytes = base64ToUint8Array(base64Image);

        return { data: bytes, width, height };
      }

      downloadBtn.addEventListener("click", async () => {
        const fullText = mathInput.value;
        if (!fullText.trim()) {
          alert("Vui l√≤ng nh·∫≠p n·ªôi dung.");
          return;
        }

        downloadBtn.disabled = true;
        downloadBtn.textContent = "‚è≥ ƒêang x·ª≠ l√Ω...";

        try {
          const docParagraphs = [];
          const regex = /(\$\$?[\s\S]+?\$\$?)/g; // kh·ªõp $...$ ho·∫∑c $$...$$

          const lines = fullText.split("\n");
          for (const line of lines) {
            if (!line.trim()) {
              // d√≤ng tr·ªëng ‚Üí paragraph tr·ªëng ƒë·ªÉ xu·ªëng d√≤ng
              docParagraphs.push(new Paragraph({ children: [new TextRun("")] }));
              continue;
            }

            const children = [];
            const parts = line.split(regex).filter(Boolean);

            for (const part of parts) {
              if (part.match(regex)) {
                const image = await renderMathToImage(part);
                if (image) {
                  children.push(
                    new ImageRun({
                      data: image.data, // Uint8Array
                      transformation: { width: Math.max(1, image.width), height: Math.max(1, image.height) },
                    })
                  );
                }
              } else {
                children.push(new TextRun(part));
              }
            }

            // CƒÉn gi·ªØa n·∫øu c·∫£ d√≤ng ch·ªâ c√≥ m·ªôt kh·ªëi $$...$$
            let alignment = AlignmentType.LEFT;
            const trimmed = line.trim();
            if (trimmed.startsWith("$$") && trimmed.endsWith("$$") && parts.length === 1) {
              alignment = AlignmentType.CENTER;
            }

            docParagraphs.push(new Paragraph({ children, alignment }));
          }

          const doc = new Document({
            sections: [
              {
                properties: {},
                children: docParagraphs,
              },
            ],
          });

          const blobRaw = await Packer.toBlob(doc);
          const blob = new Blob([blobRaw], { type: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" });
          const name = (fileNameInput.value || "document.docx").replace(/\s+$/g, "");
          saveAs(blob, name || "document.docx");
        } catch (error) {
          console.error("L·ªói khi t·∫°o file DOCX:", error);
          alert("ƒê√£ x·∫£y ra l·ªói khi t·∫°o file. Vui l√≤ng m·ªü Console (F12) ƒë·ªÉ xem chi ti·∫øt.");
        } finally {
          downloadBtn.disabled = false;
          downloadBtn.textContent = "üì• T·∫£i xu·ªëng file .docx";
        }
      });
    }
  </script>

  <!-- MathJax (t·∫£i sau khi c·∫•u h√¨nh ·ªü tr√™n) -->
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" crossorigin="anonymous"></script>
</head>
<body>
  <div class="container">
    <h2>C√¥ng c·ª• Download DOCX (B·∫£n cu·ªëi)</h2>
    <textarea id="mathInput" placeholder="Nh·∫≠p ƒë·ªÅ b√†i t·∫°i ƒë√¢y...&#10;D√πng $...$ cho c√¥ng th·ª©c inline, v√≠ d·ª•: ph∆∞∆°ng tr√¨nh $x^2 - 2x + 1 = 0$.&#10;D√πng $$...$$ cho c√¥ng th·ª©c ri√™ng m·ªôt d√≤ng v√† s·∫Ω ƒë∆∞·ª£c cƒÉn gi·ªØa.&#10;$$E = mc^2$$"></textarea>
    <input type="text" id="fileName" value="baitap_toan.docx" placeholder="T√™n file..." />
    <button id="downloadBtn">üì• T·∫£i xu·ªëng file .docx</button>
  </div>

  <!-- V√πng render ·∫©n ƒë·ªÉ MathJax t·∫°o SVG -->
  <div id="render-hidden" style="position: absolute; visibility: hidden; left: -9999px;"></div>
</body>
</html>

